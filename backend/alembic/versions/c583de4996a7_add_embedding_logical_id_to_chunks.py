"""add_embedding_logical_id_to_chunks

Revision ID: c583de4996a7
Revises: 9d1910135b7c
Create Date: 2025-06-24 00:00:00.000000

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
# If you are using sqlalchemy_pgvector for a VECTOR type:
# from sqlalchemy_pgvector.alembic import VectorOp # Or similar import based on library

# revision identifiers, used by Alembic.
revision: str = 'c583de4996a7'
down_revision: Union[str, None] = '5ae6f76c6288' # Corrected: Depends on the migration that created document_chunks
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('document_chunks',
        sa.Column('embedding', sa.Text(), nullable=True) # Placeholder: Use sa.TEXT or pgvector.VECTOR(dims)
    )
    op.add_column('document_chunks',
        sa.Column('logical_chunk_id', sa.String(length=255), nullable=True)
    )
    # Create a UNIQUE index on logical_chunk_id because it's a UUID and should be globally unique.
    # This supports the ON CONFLICT (logical_chunk_id) clause.
    op.create_index(op.f('ix_document_chunks_logical_chunk_id'), 'document_chunks', ['logical_chunk_id'], unique=True)

    # The unique constraint on (document_id, logical_chunk_id) might be redundant if logical_chunk_id is globally unique.
    # However, keeping it doesn't harm and ensures data integrity if, for some reason, logical_chunk_id wasn't globally unique.
    # For ON CONFLICT (logical_chunk_id) to work, the unique=True index above is the key.
    # If we were to use ON CONFLICT (document_id, logical_chunk_id), then the _document_logical_chunk_uc constraint would be the target.
    # Given current code uses ON CONFLICT (logical_chunk_id), the unique index on logical_chunk_id is essential.
    # Let's keep the composite constraint for now as it provides an additional layer of integrity,
    # though the single unique index on logical_chunk_id is what vector_store_handler.py will rely on.
    op.create_unique_constraint(
        '_document_logical_chunk_uc', # Constraint name
        'document_chunks',
        ['document_id', 'logical_chunk_id'] # This constraint still makes sense.
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint('_document_logical_chunk_uc', 'document_chunks', type_='unique')
    # Ensure the index name matches what op.f() would generate for unique=True if it's different,
    # or use the explicit name if provided during creation. Assuming op.f() handles it.
    op.drop_index(op.f('ix_document_chunks_logical_chunk_id'), table_name='document_chunks')
    op.drop_column('document_chunks', 'logical_chunk_id')
    op.drop_column('document_chunks', 'embedding')
    # ### end Alembic commands ###
